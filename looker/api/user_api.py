# coding: utf-8

"""
    Looker API 3.0 Reference

    ### Authorization  The Looker API uses Looker **API3** credentials for authorization and access control. Looker admins can create API3 credentials on Looker's **Admin/Users** page. Pass API3 credentials to the **/login** endpoint to obtain a temporary access_token. Include that access_token in the Authorization header of Looker API requests. For details, see [Looker API Authorization](https://looker.com/docs/r/api/authorization)  ### Client SDKs  The Looker API is a RESTful system that should be usable by any programming language capable of making HTTPS requests. Client SDKs for a variety of programming languages can be generated from the Looker API's Swagger JSON metadata to streamline use of the Looker API in your applications. A client SDK for Ruby is available as an example. For more information, see [Looker API Client SDKs](https://looker.com/docs/r/api/client_sdks)  ### Try It Out!  The 'api-docs' page served by the Looker instance includes 'Try It Out!' buttons for each API method. After logging in with API3 credentials, you can use the \"Try It Out!\" buttons to call the API directly from the documentation page to interactively explore API features and responses.  ### Versioning  Future releases of Looker will expand this API release-by-release to securely expose more and more of the core power of Looker to API client applications. API endpoints marked as \"beta\" may receive breaking changes without warning. Stable (non-beta) API endpoints should not receive breaking changes in future releases. For more information, see [Looker API Versioning](https://looker.com/docs/r/api/versioning)   # noqa: E501

    OpenAPI spec version: 3.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from looker.api_client import ApiClient


class UserApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def all_user_access_filters(self, user_id, **kwargs):  # noqa: E501
        """Get All Access Filters  # noqa: E501

        ### Access filter for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.all_user_access_filters(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: list[AccessFilter]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.all_user_access_filters_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.all_user_access_filters_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def all_user_access_filters_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get All Access Filters  # noqa: E501

        ### Access filter for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.all_user_access_filters_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: list[AccessFilter]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method all_user_access_filters" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `all_user_access_filters`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/access_filters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[AccessFilter]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def all_user_credentials_api3s(self, user_id, **kwargs):  # noqa: E501
        """Get All API 3 Credentials  # noqa: E501

        ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.all_user_credentials_api3s(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: list[CredentialsApi3]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.all_user_credentials_api3s_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.all_user_credentials_api3s_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def all_user_credentials_api3s_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get All API 3 Credentials  # noqa: E501

        ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.all_user_credentials_api3s_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: list[CredentialsApi3]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method all_user_credentials_api3s" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `all_user_credentials_api3s`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_api3', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CredentialsApi3]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def all_user_credentials_embeds(self, user_id, **kwargs):  # noqa: E501
        """Get All Embedding Credentials  # noqa: E501

        ### Embed login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.all_user_credentials_embeds(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: list[CredentialsEmbed]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.all_user_credentials_embeds_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.all_user_credentials_embeds_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def all_user_credentials_embeds_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get All Embedding Credentials  # noqa: E501

        ### Embed login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.all_user_credentials_embeds_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: list[CredentialsEmbed]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method all_user_credentials_embeds" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `all_user_credentials_embeds`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_embed', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[CredentialsEmbed]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def all_user_sessions(self, user_id, **kwargs):  # noqa: E501
        """Get All Web Login Sessions  # noqa: E501

        ### Web login session for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.all_user_sessions(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: list[Session]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.all_user_sessions_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.all_user_sessions_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def all_user_sessions_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get All Web Login Sessions  # noqa: E501

        ### Web login session for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.all_user_sessions_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: list[Session]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method all_user_sessions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `all_user_sessions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/sessions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Session]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def all_users(self, **kwargs):  # noqa: E501
        """Get All Users  # noqa: E501

        ### Get information about all users.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.all_users(async=True)
        >>> result = thread.get()

        :param async bool
        :param str fields: Requested fields.
        :param int page: Requested page.
        :param int per_page: Results per page.
        :param str sorts: Fields to sort by.
        :param list[int] ids: Optional list of ids to get specific users.
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.all_users_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.all_users_with_http_info(**kwargs)  # noqa: E501
            return data

    def all_users_with_http_info(self, **kwargs):  # noqa: E501
        """Get All Users  # noqa: E501

        ### Get information about all users.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.all_users_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str fields: Requested fields.
        :param int page: Requested page.
        :param int per_page: Results per page.
        :param str sorts: Fields to sort by.
        :param list[int] ids: Optional list of ids to get specific users.
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'page', 'per_page', 'sorts', 'ids']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method all_users" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501
        if 'sorts' in params:
            query_params.append(('sorts', params['sorts']))  # noqa: E501
        if 'ids' in params:
            query_params.append(('ids', params['ids']))  # noqa: E501
            collection_formats['ids'] = 'csv'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[User]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_user(self, **kwargs):  # noqa: E501
        """Create User  # noqa: E501

        ### Create a user with the specified information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_user(async=True)
        >>> result = thread.get()

        :param async bool
        :param User body: User
        :param str fields: Requested fields.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_user_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.create_user_with_http_info(**kwargs)  # noqa: E501
            return data

    def create_user_with_http_info(self, **kwargs):  # noqa: E501
        """Create User  # noqa: E501

        ### Create a user with the specified information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_user_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param User body: User
        :param str fields: Requested fields.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_user" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_user_access_filter(self, user_id, **kwargs):  # noqa: E501
        """Create Access Filter  # noqa: E501

        ### Access filter for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_user_access_filter(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param AccessFilter body: Access Filter
        :param str fields: Requested fields.
        :return: AccessFilter
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_user_access_filter_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_user_access_filter_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def create_user_access_filter_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Create Access Filter  # noqa: E501

        ### Access filter for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_user_access_filter_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param AccessFilter body: Access Filter
        :param str fields: Requested fields.
        :return: AccessFilter
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_user_access_filter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `create_user_access_filter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/access_filters', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessFilter',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_user_credentials_api(self, user_id, **kwargs):  # noqa: E501
        """Create API Credential  # noqa: E501

        ### Create API Credential. SUPPORT FOR THIS HAS BEEN REMOVED.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_user_credentials_api(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param CredentialsApi body: API Credential
        :return: CredentialsApi
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_user_credentials_api_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_user_credentials_api_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def create_user_credentials_api_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Create API Credential  # noqa: E501

        ### Create API Credential. SUPPORT FOR THIS HAS BEEN REMOVED.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_user_credentials_api_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param CredentialsApi body: API Credential
        :return: CredentialsApi
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_user_credentials_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `create_user_credentials_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_api', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialsApi',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_user_credentials_api3(self, user_id, **kwargs):  # noqa: E501
        """Create API 3 Credential  # noqa: E501

        ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_user_credentials_api3(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param CredentialsApi3 body: API 3 Credential
        :param str fields: Requested fields.
        :return: CredentialsApi3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_user_credentials_api3_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_user_credentials_api3_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def create_user_credentials_api3_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Create API 3 Credential  # noqa: E501

        ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_user_credentials_api3_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param CredentialsApi3 body: API 3 Credential
        :param str fields: Requested fields.
        :return: CredentialsApi3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_user_credentials_api3" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `create_user_credentials_api3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_api3', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialsApi3',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_user_credentials_email(self, user_id, **kwargs):  # noqa: E501
        """Create Email/Password Credential  # noqa: E501

        ### Email/password login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_user_credentials_email(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param CredentialsEmail body: Email/Password Credential
        :param str fields: Requested fields.
        :return: CredentialsEmail
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_user_credentials_email_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_user_credentials_email_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def create_user_credentials_email_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Create Email/Password Credential  # noqa: E501

        ### Email/password login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_user_credentials_email_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param CredentialsEmail body: Email/Password Credential
        :param str fields: Requested fields.
        :return: CredentialsEmail
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_user_credentials_email" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `create_user_credentials_email`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_email', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialsEmail',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_user_credentials_email_password_reset(self, user_id, **kwargs):  # noqa: E501
        """Create Password Reset Token  # noqa: E501

        ### Create a password reset token. This will create a cryptographically secure random password reset token for the user. If the user already has a password reset token then this invalidates the old token and creates a new one. The token is expressed as the 'password_reset_url' of the user's email/password credential object. This takes an optional 'expires' param to indicate if the new token should be an expiring token. Tokens that expire are typically used for self-service password resets for existing users. Invitation emails for new users typically are not set to expire. The expire period is always 60 minutes when expires is enabled. This method can be called with an empty body.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_user_credentials_email_password_reset(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param bool expires: Expiring token.
        :param str fields: Requested fields.
        :return: CredentialsEmail
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_user_credentials_email_password_reset_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_user_credentials_email_password_reset_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def create_user_credentials_email_password_reset_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Create Password Reset Token  # noqa: E501

        ### Create a password reset token. This will create a cryptographically secure random password reset token for the user. If the user already has a password reset token then this invalidates the old token and creates a new one. The token is expressed as the 'password_reset_url' of the user's email/password credential object. This takes an optional 'expires' param to indicate if the new token should be an expiring token. Tokens that expire are typically used for self-service password resets for existing users. Invitation emails for new users typically are not set to expire. The expire period is always 60 minutes when expires is enabled. This method can be called with an empty body.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_user_credentials_email_password_reset_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param bool expires: Expiring token.
        :param str fields: Requested fields.
        :return: CredentialsEmail
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'expires', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_user_credentials_email_password_reset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `create_user_credentials_email_password_reset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'expires' in params:
            query_params.append(('expires', params['expires']))  # noqa: E501
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_email/password_reset', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialsEmail',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_user_credentials_totp(self, user_id, **kwargs):  # noqa: E501
        """Create Two-Factor Credential  # noqa: E501

        ### Two-factor login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_user_credentials_totp(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param CredentialsTotp body: Two-Factor Credential
        :param str fields: Requested fields.
        :return: CredentialsTotp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.create_user_credentials_totp_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.create_user_credentials_totp_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def create_user_credentials_totp_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Create Two-Factor Credential  # noqa: E501

        ### Two-factor login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.create_user_credentials_totp_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param CredentialsTotp body: Two-Factor Credential
        :param str fields: Requested fields.
        :return: CredentialsTotp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_user_credentials_totp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `create_user_credentials_totp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_totp', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialsTotp',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user(self, user_id, **kwargs):  # noqa: E501
        """Delete User  # noqa: E501

        ### Delete the user with a specific id.  **DANGER** this will delete the user and all looks and other information owned by the user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_user_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def delete_user_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Delete User  # noqa: E501

        ### Delete the user with a specific id.  **DANGER** this will delete the user and all looks and other information owned by the user.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_access_filter(self, user_id, access_filter_id, **kwargs):  # noqa: E501
        """Delete Access Filter  # noqa: E501

        ### Access filter for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_access_filter(user_id, access_filter_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param int access_filter_id: id of Access Filter (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_user_access_filter_with_http_info(user_id, access_filter_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_access_filter_with_http_info(user_id, access_filter_id, **kwargs)  # noqa: E501
            return data

    def delete_user_access_filter_with_http_info(self, user_id, access_filter_id, **kwargs):  # noqa: E501
        """Delete Access Filter  # noqa: E501

        ### Access filter for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_access_filter_with_http_info(user_id, access_filter_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param int access_filter_id: id of Access Filter (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'access_filter_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_access_filter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_user_access_filter`")  # noqa: E501
        # verify the required parameter 'access_filter_id' is set
        if ('access_filter_id' not in params or
                params['access_filter_id'] is None):
            raise ValueError("Missing the required parameter `access_filter_id` when calling `delete_user_access_filter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'access_filter_id' in params:
            path_params['access_filter_id'] = params['access_filter_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/access_filters/{access_filter_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_attribute_user_value(self, user_id, user_attribute_id, **kwargs):  # noqa: E501
        """Delete User Attribute User Value  # noqa: E501

        ### Delete a user attribute value from a user's account settings.  After the user attribute value is deleted from the user's account settings, subsequent requests for the user attribute value for this user will draw from the user's groups or the default value of the user attribute. See [Get User Attribute Values](#!/User/user_attribute_user_values) for more information about how user attribute values are resolved.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_attribute_user_value(user_id, user_attribute_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param int user_attribute_id: Id of user attribute (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_user_attribute_user_value_with_http_info(user_id, user_attribute_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_attribute_user_value_with_http_info(user_id, user_attribute_id, **kwargs)  # noqa: E501
            return data

    def delete_user_attribute_user_value_with_http_info(self, user_id, user_attribute_id, **kwargs):  # noqa: E501
        """Delete User Attribute User Value  # noqa: E501

        ### Delete a user attribute value from a user's account settings.  After the user attribute value is deleted from the user's account settings, subsequent requests for the user attribute value for this user will draw from the user's groups or the default value of the user attribute. See [Get User Attribute Values](#!/User/user_attribute_user_values) for more information about how user attribute values are resolved.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_attribute_user_value_with_http_info(user_id, user_attribute_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param int user_attribute_id: Id of user attribute (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'user_attribute_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_attribute_user_value" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_user_attribute_user_value`")  # noqa: E501
        # verify the required parameter 'user_attribute_id' is set
        if ('user_attribute_id' not in params or
                params['user_attribute_id'] is None):
            raise ValueError("Missing the required parameter `user_attribute_id` when calling `delete_user_attribute_user_value`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'user_attribute_id' in params:
            path_params['user_attribute_id'] = params['user_attribute_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/attribute_values/{user_attribute_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_credentials_api(self, user_id, **kwargs):  # noqa: E501
        """Delete API Credential  # noqa: E501

        ### API login information for the specified user. This is for 'API Users' used for the 'old' query API. THIS SUPPORT HAS BEEN REMOVED.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_api(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_user_credentials_api_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_credentials_api_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def delete_user_credentials_api_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Delete API Credential  # noqa: E501

        ### API login information for the specified user. This is for 'API Users' used for the 'old' query API. THIS SUPPORT HAS BEEN REMOVED.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_api_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_credentials_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_user_credentials_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_api', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_credentials_api3(self, user_id, credentials_api3_id, **kwargs):  # noqa: E501
        """Delete API 3 Credential  # noqa: E501

        ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_api3(user_id, credentials_api3_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param int credentials_api3_id: id of API 3 Credential (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_user_credentials_api3_with_http_info(user_id, credentials_api3_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_credentials_api3_with_http_info(user_id, credentials_api3_id, **kwargs)  # noqa: E501
            return data

    def delete_user_credentials_api3_with_http_info(self, user_id, credentials_api3_id, **kwargs):  # noqa: E501
        """Delete API 3 Credential  # noqa: E501

        ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_api3_with_http_info(user_id, credentials_api3_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param int credentials_api3_id: id of API 3 Credential (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'credentials_api3_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_credentials_api3" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_user_credentials_api3`")  # noqa: E501
        # verify the required parameter 'credentials_api3_id' is set
        if ('credentials_api3_id' not in params or
                params['credentials_api3_id'] is None):
            raise ValueError("Missing the required parameter `credentials_api3_id` when calling `delete_user_credentials_api3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'credentials_api3_id' in params:
            path_params['credentials_api3_id'] = params['credentials_api3_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_api3/{credentials_api3_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_credentials_email(self, user_id, **kwargs):  # noqa: E501
        """Delete Email/Password Credential  # noqa: E501

        ### Email/password login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_email(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_user_credentials_email_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_credentials_email_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def delete_user_credentials_email_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Delete Email/Password Credential  # noqa: E501

        ### Email/password login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_email_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_credentials_email" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_user_credentials_email`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_email', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_credentials_embed(self, user_id, credentials_embed_id, **kwargs):  # noqa: E501
        """Delete Embedding Credential  # noqa: E501

        ### Embed login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_embed(user_id, credentials_embed_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param int credentials_embed_id: id of Embedding Credential (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_user_credentials_embed_with_http_info(user_id, credentials_embed_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_credentials_embed_with_http_info(user_id, credentials_embed_id, **kwargs)  # noqa: E501
            return data

    def delete_user_credentials_embed_with_http_info(self, user_id, credentials_embed_id, **kwargs):  # noqa: E501
        """Delete Embedding Credential  # noqa: E501

        ### Embed login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_embed_with_http_info(user_id, credentials_embed_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param int credentials_embed_id: id of Embedding Credential (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'credentials_embed_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_credentials_embed" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_user_credentials_embed`")  # noqa: E501
        # verify the required parameter 'credentials_embed_id' is set
        if ('credentials_embed_id' not in params or
                params['credentials_embed_id'] is None):
            raise ValueError("Missing the required parameter `credentials_embed_id` when calling `delete_user_credentials_embed`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'credentials_embed_id' in params:
            path_params['credentials_embed_id'] = params['credentials_embed_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_embed/{credentials_embed_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_credentials_google(self, user_id, **kwargs):  # noqa: E501
        """Delete Google Auth Credential  # noqa: E501

        ### Google authentication login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_google(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_user_credentials_google_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_credentials_google_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def delete_user_credentials_google_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Delete Google Auth Credential  # noqa: E501

        ### Google authentication login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_google_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_credentials_google" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_user_credentials_google`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_google', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_credentials_ldap(self, user_id, **kwargs):  # noqa: E501
        """Delete LDAP Credential  # noqa: E501

        ### LDAP login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_ldap(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_user_credentials_ldap_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_credentials_ldap_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def delete_user_credentials_ldap_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Delete LDAP Credential  # noqa: E501

        ### LDAP login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_ldap_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_credentials_ldap" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_user_credentials_ldap`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_ldap', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_credentials_looker_openid(self, user_id, **kwargs):  # noqa: E501
        """Delete Looker OpenId Credential  # noqa: E501

        ### Looker Openid login information for the specified user. Used by Looker Analysts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_looker_openid(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_user_credentials_looker_openid_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_credentials_looker_openid_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def delete_user_credentials_looker_openid_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Delete Looker OpenId Credential  # noqa: E501

        ### Looker Openid login information for the specified user. Used by Looker Analysts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_looker_openid_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_credentials_looker_openid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_user_credentials_looker_openid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_looker_openid', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_credentials_oidc(self, user_id, **kwargs):  # noqa: E501
        """Delete OIDC Auth Credential  # noqa: E501

        ### OpenID Connect (OIDC) authentication login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_oidc(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_user_credentials_oidc_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_credentials_oidc_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def delete_user_credentials_oidc_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Delete OIDC Auth Credential  # noqa: E501

        ### OpenID Connect (OIDC) authentication login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_oidc_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_credentials_oidc" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_user_credentials_oidc`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_oidc', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_credentials_saml(self, user_id, **kwargs):  # noqa: E501
        """Delete Saml Auth Credential  # noqa: E501

        ### Saml authentication login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_saml(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_user_credentials_saml_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_credentials_saml_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def delete_user_credentials_saml_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Delete Saml Auth Credential  # noqa: E501

        ### Saml authentication login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_saml_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_credentials_saml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_user_credentials_saml`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_saml', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_credentials_totp(self, user_id, **kwargs):  # noqa: E501
        """Delete Two-Factor Credential  # noqa: E501

        ### Two-factor login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_totp(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_user_credentials_totp_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_credentials_totp_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def delete_user_credentials_totp_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Delete Two-Factor Credential  # noqa: E501

        ### Two-factor login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_credentials_totp_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_credentials_totp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_user_credentials_totp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_totp', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_user_session(self, user_id, session_id, **kwargs):  # noqa: E501
        """Delete Web Login Session  # noqa: E501

        ### Web login session for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_session(user_id, session_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param int session_id: id of Web Login Session (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.delete_user_session_with_http_info(user_id, session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_user_session_with_http_info(user_id, session_id, **kwargs)  # noqa: E501
            return data

    def delete_user_session_with_http_info(self, user_id, session_id, **kwargs):  # noqa: E501
        """Delete Web Login Session  # noqa: E501

        ### Web login session for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.delete_user_session_with_http_info(user_id, session_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param int session_id: id of Web Login Session (required)
        :return: str
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'session_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_user_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `delete_user_session`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `delete_user_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'session_id' in params:
            path_params['session_id'] = params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/sessions/{session_id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='str',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def me(self, **kwargs):  # noqa: E501
        """Get Current User  # noqa: E501

        ### Get information about the current user; i.e. the user account currently calling the API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.me(async=True)
        >>> result = thread.get()

        :param async bool
        :param str fields: Requested fields.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.me_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.me_with_http_info(**kwargs)  # noqa: E501
            return data

    def me_with_http_info(self, **kwargs):  # noqa: E501
        """Get Current User  # noqa: E501

        ### Get information about the current user; i.e. the user account currently calling the API.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.me_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str fields: Requested fields.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method me" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/user', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_users(self, **kwargs):  # noqa: E501
        """Search Users  # noqa: E501

        ### Search users.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_users(async=True)
        >>> result = thread.get()

        :param async bool
        :param str fields: Requested fields.
        :param int page: Requested page.
        :param int per_page: Results per page.
        :param str sorts: Fields to sort by.
        :param int id: Match User Id.
        :param str first_name: Match First name.
        :param str last_name: Match Last name.
        :param bool verified_looker_employee: Match Verified Looker employee.
        :param str email: Match Email Address.
        :param bool is_disabled: Match Is disabled.
        :param bool filter_or: Do an OR search with parameters
        :param int content_metadata_id: Id of content metadata to which users must have access
        :param int group_id: Id of group of which users must be directly members
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_users_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_users_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_users_with_http_info(self, **kwargs):  # noqa: E501
        """Search Users  # noqa: E501

        ### Search users.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_users_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str fields: Requested fields.
        :param int page: Requested page.
        :param int per_page: Results per page.
        :param str sorts: Fields to sort by.
        :param int id: Match User Id.
        :param str first_name: Match First name.
        :param str last_name: Match Last name.
        :param bool verified_looker_employee: Match Verified Looker employee.
        :param str email: Match Email Address.
        :param bool is_disabled: Match Is disabled.
        :param bool filter_or: Do an OR search with parameters
        :param int content_metadata_id: Id of content metadata to which users must have access
        :param int group_id: Id of group of which users must be directly members
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['fields', 'page', 'per_page', 'sorts', 'id', 'first_name', 'last_name', 'verified_looker_employee', 'email', 'is_disabled', 'filter_or', 'content_metadata_id', 'group_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_users" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501
        if 'sorts' in params:
            query_params.append(('sorts', params['sorts']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'first_name' in params:
            query_params.append(('first_name', params['first_name']))  # noqa: E501
        if 'last_name' in params:
            query_params.append(('last_name', params['last_name']))  # noqa: E501
        if 'verified_looker_employee' in params:
            query_params.append(('verified_looker_employee', params['verified_looker_employee']))  # noqa: E501
        if 'email' in params:
            query_params.append(('email', params['email']))  # noqa: E501
        if 'is_disabled' in params:
            query_params.append(('is_disabled', params['is_disabled']))  # noqa: E501
        if 'filter_or' in params:
            query_params.append(('filter_or', params['filter_or']))  # noqa: E501
        if 'content_metadata_id' in params:
            query_params.append(('content_metadata_id', params['content_metadata_id']))  # noqa: E501
        if 'group_id' in params:
            query_params.append(('group_id', params['group_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[User]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_users_names(self, pattern, **kwargs):  # noqa: E501
        """Search User Names  # noqa: E501

        ### Search users where first_name OR last_name OR email matches a string.  The results will be AND'd with any additional search parameters that are (optionally) included.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_users_names(pattern, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pattern: Pattern to match. (required)
        :param str fields: Requested fields.
        :param int page: Requested page.
        :param int per_page: Results per page.
        :param str sorts: Fields to sort by.
        :param int id: Match User Id.
        :param str first_name: Match First name.
        :param str last_name: Match Last name.
        :param bool verified_looker_employee: Match Verified Looker employee.
        :param str email: Match Email Address.
        :param bool is_disabled: Match Is disabled.
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.search_users_names_with_http_info(pattern, **kwargs)  # noqa: E501
        else:
            (data) = self.search_users_names_with_http_info(pattern, **kwargs)  # noqa: E501
            return data

    def search_users_names_with_http_info(self, pattern, **kwargs):  # noqa: E501
        """Search User Names  # noqa: E501

        ### Search users where first_name OR last_name OR email matches a string.  The results will be AND'd with any additional search parameters that are (optionally) included.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.search_users_names_with_http_info(pattern, async=True)
        >>> result = thread.get()

        :param async bool
        :param str pattern: Pattern to match. (required)
        :param str fields: Requested fields.
        :param int page: Requested page.
        :param int per_page: Results per page.
        :param str sorts: Fields to sort by.
        :param int id: Match User Id.
        :param str first_name: Match First name.
        :param str last_name: Match Last name.
        :param bool verified_looker_employee: Match Verified Looker employee.
        :param str email: Match Email Address.
        :param bool is_disabled: Match Is disabled.
        :return: list[User]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['pattern', 'fields', 'page', 'per_page', 'sorts', 'id', 'first_name', 'last_name', 'verified_looker_employee', 'email', 'is_disabled']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_users_names" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'pattern' is set
        if ('pattern' not in params or
                params['pattern'] is None):
            raise ValueError("Missing the required parameter `pattern` when calling `search_users_names`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'pattern' in params:
            path_params['pattern'] = params['pattern']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501
        if 'sorts' in params:
            query_params.append(('sorts', params['sorts']))  # noqa: E501
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'first_name' in params:
            query_params.append(('first_name', params['first_name']))  # noqa: E501
        if 'last_name' in params:
            query_params.append(('last_name', params['last_name']))  # noqa: E501
        if 'verified_looker_employee' in params:
            query_params.append(('verified_looker_employee', params['verified_looker_employee']))  # noqa: E501
        if 'email' in params:
            query_params.append(('email', params['email']))  # noqa: E501
        if 'is_disabled' in params:
            query_params.append(('is_disabled', params['is_disabled']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/search/names/{pattern}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[User]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_user_attribute_user_value(self, user_id, user_attribute_id, body, **kwargs):  # noqa: E501
        """Set User Attribute User Value  # noqa: E501

        ### Store a custom value for a user attribute in a user's account settings.  Per-user user attribute values take precedence over group or default values.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_user_attribute_user_value(user_id, user_attribute_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param int user_attribute_id: Id of user attribute (required)
        :param UserAttributeWithValue body: New attribute value for user. (required)
        :return: UserAttributeWithValue
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_user_attribute_user_value_with_http_info(user_id, user_attribute_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.set_user_attribute_user_value_with_http_info(user_id, user_attribute_id, body, **kwargs)  # noqa: E501
            return data

    def set_user_attribute_user_value_with_http_info(self, user_id, user_attribute_id, body, **kwargs):  # noqa: E501
        """Set User Attribute User Value  # noqa: E501

        ### Store a custom value for a user attribute in a user's account settings.  Per-user user attribute values take precedence over group or default values.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_user_attribute_user_value_with_http_info(user_id, user_attribute_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param int user_attribute_id: Id of user attribute (required)
        :param UserAttributeWithValue body: New attribute value for user. (required)
        :return: UserAttributeWithValue
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'user_attribute_id', 'body']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_user_attribute_user_value" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `set_user_attribute_user_value`")  # noqa: E501
        # verify the required parameter 'user_attribute_id' is set
        if ('user_attribute_id' not in params or
                params['user_attribute_id'] is None):
            raise ValueError("Missing the required parameter `user_attribute_id` when calling `set_user_attribute_user_value`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `set_user_attribute_user_value`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'user_attribute_id' in params:
            path_params['user_attribute_id'] = params['user_attribute_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/attribute_values/{user_attribute_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UserAttributeWithValue',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_user_roles(self, user_id, body, **kwargs):  # noqa: E501
        """Set User Roles  # noqa: E501

        ### Set roles of the user with a specific id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_user_roles(user_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param list[int] body: array of roles ids for user (required)
        :param str fields: Requested fields.
        :return: list[Role]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.set_user_roles_with_http_info(user_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.set_user_roles_with_http_info(user_id, body, **kwargs)  # noqa: E501
            return data

    def set_user_roles_with_http_info(self, user_id, body, **kwargs):  # noqa: E501
        """Set User Roles  # noqa: E501

        ### Set roles of the user with a specific id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.set_user_roles_with_http_info(user_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param list[int] body: array of roles ids for user (required)
        :param str fields: Requested fields.
        :return: list[Role]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_user_roles" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `set_user_roles`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `set_user_roles`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/roles', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Role]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user(self, user_id, body, **kwargs):  # noqa: E501
        """Update User  # noqa: E501

        ### Update information about the user with a specific id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_user(user_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param User body: User (required)
        :param str fields: Requested fields.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_user_with_http_info(user_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_user_with_http_info(user_id, body, **kwargs)  # noqa: E501
            return data

    def update_user_with_http_info(self, user_id, body, **kwargs):  # noqa: E501
        """Update User  # noqa: E501

        ### Update information about the user with a specific id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_user_with_http_info(user_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param User body: User (required)
        :param str fields: Requested fields.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `update_user`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user_access_filter(self, user_id, access_filter_id, body, **kwargs):  # noqa: E501
        """Update Access Filter  # noqa: E501

        ### Access filter for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_user_access_filter(user_id, access_filter_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param int access_filter_id: id of Access Filter (required)
        :param AccessFilter body: Access Filter (required)
        :param str fields: Requested fields.
        :return: AccessFilter
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_user_access_filter_with_http_info(user_id, access_filter_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_user_access_filter_with_http_info(user_id, access_filter_id, body, **kwargs)  # noqa: E501
            return data

    def update_user_access_filter_with_http_info(self, user_id, access_filter_id, body, **kwargs):  # noqa: E501
        """Update Access Filter  # noqa: E501

        ### Access filter for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_user_access_filter_with_http_info(user_id, access_filter_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param int access_filter_id: id of Access Filter (required)
        :param AccessFilter body: Access Filter (required)
        :param str fields: Requested fields.
        :return: AccessFilter
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'access_filter_id', 'body', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user_access_filter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `update_user_access_filter`")  # noqa: E501
        # verify the required parameter 'access_filter_id' is set
        if ('access_filter_id' not in params or
                params['access_filter_id'] is None):
            raise ValueError("Missing the required parameter `access_filter_id` when calling `update_user_access_filter`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_user_access_filter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'access_filter_id' in params:
            path_params['access_filter_id'] = params['access_filter_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/access_filters/{access_filter_id}', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessFilter',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_user_credentials_email(self, user_id, body, **kwargs):  # noqa: E501
        """Update Email/Password Credential  # noqa: E501

        ### Email/password login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_user_credentials_email(user_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param CredentialsEmail body: Email/Password Credential (required)
        :param str fields: Requested fields.
        :return: CredentialsEmail
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.update_user_credentials_email_with_http_info(user_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_user_credentials_email_with_http_info(user_id, body, **kwargs)  # noqa: E501
            return data

    def update_user_credentials_email_with_http_info(self, user_id, body, **kwargs):  # noqa: E501
        """Update Email/Password Credential  # noqa: E501

        ### Email/password login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.update_user_credentials_email_with_http_info(user_id, body, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param CredentialsEmail body: Email/Password Credential (required)
        :param str fields: Requested fields.
        :return: CredentialsEmail
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'body', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_user_credentials_email" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `update_user_credentials_email`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_user_credentials_email`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_email', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialsEmail',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user(self, user_id, **kwargs):  # noqa: E501
        """Get User by Id  # noqa: E501

        ### Get information about the user with a specific id.  If the caller is an admin or the caller is the user being specified, then full user information will be returned. Otherwise, a minimal 'public' variant of the user information will be returned. This contains The user name and avatar url, but no sensitive information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param str fields: Requested fields.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.user_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def user_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get User by Id  # noqa: E501

        ### Get information about the user with a specific id.  If the caller is an admin or the caller is the user being specified, then full user information will be returned. Otherwise, a minimal 'public' variant of the user information will be returned. This contains The user name and avatar url, but no sensitive information.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param str fields: Requested fields.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_access_filter(self, user_id, access_filter_id, **kwargs):  # noqa: E501
        """Get Access Filter  # noqa: E501

        ### Access filter for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_access_filter(user_id, access_filter_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param int access_filter_id: Id of Access Filter (required)
        :param str fields: Requested fields.
        :return: AccessFilter
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.user_access_filter_with_http_info(user_id, access_filter_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_access_filter_with_http_info(user_id, access_filter_id, **kwargs)  # noqa: E501
            return data

    def user_access_filter_with_http_info(self, user_id, access_filter_id, **kwargs):  # noqa: E501
        """Get Access Filter  # noqa: E501

        ### Access filter for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_access_filter_with_http_info(user_id, access_filter_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param int access_filter_id: Id of Access Filter (required)
        :param str fields: Requested fields.
        :return: AccessFilter
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'access_filter_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_access_filter" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_access_filter`")  # noqa: E501
        # verify the required parameter 'access_filter_id' is set
        if ('access_filter_id' not in params or
                params['access_filter_id'] is None):
            raise ValueError("Missing the required parameter `access_filter_id` when calling `user_access_filter`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'access_filter_id' in params:
            path_params['access_filter_id'] = params['access_filter_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/access_filters/{access_filter_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccessFilter',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_attribute_user_values(self, user_id, **kwargs):  # noqa: E501
        """Get User Attribute Values  # noqa: E501

        ### Get user attribute values for a given user.  Returns the values of specified user attributes (or all user attributes) for a certain user.  A value for each user attribute is searched for in the following locations, in this order: 1. in the user's account information 1. in groups that the user is a member of 1. the default value of the user attribute  If more than one group has a value defined for a user attribute, the group with the lowest rank wins.  The response will only include user attributes for which values were found. Use `include_unset=true` to include empty records for user attributes with no value.  The value of all hidden user attributes will be blank.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_attribute_user_values(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param str fields: Requested fields.
        :param list[int] user_attribute_ids: Specific user attributes to request. Omit or leave blank to request all user attributes.
        :param bool all_values: If true, returns all values in the search path instead of just the first value found. Useful for debugging group precedence.
        :param bool include_unset: If true, returns an empty record for each requested attribute that has no user, group, or default value.
        :return: list[UserAttributeWithValue]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.user_attribute_user_values_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_attribute_user_values_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def user_attribute_user_values_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get User Attribute Values  # noqa: E501

        ### Get user attribute values for a given user.  Returns the values of specified user attributes (or all user attributes) for a certain user.  A value for each user attribute is searched for in the following locations, in this order: 1. in the user's account information 1. in groups that the user is a member of 1. the default value of the user attribute  If more than one group has a value defined for a user attribute, the group with the lowest rank wins.  The response will only include user attributes for which values were found. Use `include_unset=true` to include empty records for user attributes with no value.  The value of all hidden user attributes will be blank.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_attribute_user_values_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param str fields: Requested fields.
        :param list[int] user_attribute_ids: Specific user attributes to request. Omit or leave blank to request all user attributes.
        :param bool all_values: If true, returns all values in the search path instead of just the first value found. Useful for debugging group precedence.
        :param bool include_unset: If true, returns an empty record for each requested attribute that has no user, group, or default value.
        :return: list[UserAttributeWithValue]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'fields', 'user_attribute_ids', 'all_values', 'include_unset']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_attribute_user_values" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_attribute_user_values`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'user_attribute_ids' in params:
            query_params.append(('user_attribute_ids', params['user_attribute_ids']))  # noqa: E501
            collection_formats['user_attribute_ids'] = 'csv'  # noqa: E501
        if 'all_values' in params:
            query_params.append(('all_values', params['all_values']))  # noqa: E501
        if 'include_unset' in params:
            query_params.append(('include_unset', params['include_unset']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/attribute_values', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[UserAttributeWithValue]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_credentials_api(self, user_id, **kwargs):  # noqa: E501
        """Get API Credential  # noqa: E501

        ### API login information for the specified user. This is for 'API Users' used for the 'old' query API. THIS SUPPORT HAS BEEN REMOVED.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_api(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: CredentialsApi
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.user_credentials_api_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_credentials_api_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def user_credentials_api_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get API Credential  # noqa: E501

        ### API login information for the specified user. This is for 'API Users' used for the 'old' query API. THIS SUPPORT HAS BEEN REMOVED.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_api_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: CredentialsApi
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_credentials_api" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_credentials_api`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_api', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialsApi',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_credentials_api3(self, user_id, credentials_api3_id, **kwargs):  # noqa: E501
        """Get API 3 Credential  # noqa: E501

        ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_api3(user_id, credentials_api3_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param int credentials_api3_id: Id of API 3 Credential (required)
        :param str fields: Requested fields.
        :return: CredentialsApi3
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.user_credentials_api3_with_http_info(user_id, credentials_api3_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_credentials_api3_with_http_info(user_id, credentials_api3_id, **kwargs)  # noqa: E501
            return data

    def user_credentials_api3_with_http_info(self, user_id, credentials_api3_id, **kwargs):  # noqa: E501
        """Get API 3 Credential  # noqa: E501

        ### API 3 login information for the specified user. This is for the newer API keys that can be added for any user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_api3_with_http_info(user_id, credentials_api3_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param int credentials_api3_id: Id of API 3 Credential (required)
        :param str fields: Requested fields.
        :return: CredentialsApi3
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'credentials_api3_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_credentials_api3" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_credentials_api3`")  # noqa: E501
        # verify the required parameter 'credentials_api3_id' is set
        if ('credentials_api3_id' not in params or
                params['credentials_api3_id'] is None):
            raise ValueError("Missing the required parameter `credentials_api3_id` when calling `user_credentials_api3`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'credentials_api3_id' in params:
            path_params['credentials_api3_id'] = params['credentials_api3_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_api3/{credentials_api3_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialsApi3',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_credentials_email(self, user_id, **kwargs):  # noqa: E501
        """Get Email/Password Credential  # noqa: E501

        ### Email/password login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_email(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: CredentialsEmail
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.user_credentials_email_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_credentials_email_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def user_credentials_email_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get Email/Password Credential  # noqa: E501

        ### Email/password login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_email_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: CredentialsEmail
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_credentials_email" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_credentials_email`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_email', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialsEmail',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_credentials_embed(self, user_id, credentials_embed_id, **kwargs):  # noqa: E501
        """Get Embedding Credential  # noqa: E501

        ### Embed login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_embed(user_id, credentials_embed_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param int credentials_embed_id: Id of Embedding Credential (required)
        :param str fields: Requested fields.
        :return: CredentialsEmbed
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.user_credentials_embed_with_http_info(user_id, credentials_embed_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_credentials_embed_with_http_info(user_id, credentials_embed_id, **kwargs)  # noqa: E501
            return data

    def user_credentials_embed_with_http_info(self, user_id, credentials_embed_id, **kwargs):  # noqa: E501
        """Get Embedding Credential  # noqa: E501

        ### Embed login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_embed_with_http_info(user_id, credentials_embed_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param int credentials_embed_id: Id of Embedding Credential (required)
        :param str fields: Requested fields.
        :return: CredentialsEmbed
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'credentials_embed_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_credentials_embed" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_credentials_embed`")  # noqa: E501
        # verify the required parameter 'credentials_embed_id' is set
        if ('credentials_embed_id' not in params or
                params['credentials_embed_id'] is None):
            raise ValueError("Missing the required parameter `credentials_embed_id` when calling `user_credentials_embed`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'credentials_embed_id' in params:
            path_params['credentials_embed_id'] = params['credentials_embed_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_embed/{credentials_embed_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialsEmbed',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_credentials_google(self, user_id, **kwargs):  # noqa: E501
        """Get Google Auth Credential  # noqa: E501

        ### Google authentication login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_google(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: CredentialsGoogle
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.user_credentials_google_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_credentials_google_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def user_credentials_google_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get Google Auth Credential  # noqa: E501

        ### Google authentication login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_google_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: CredentialsGoogle
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_credentials_google" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_credentials_google`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_google', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialsGoogle',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_credentials_ldap(self, user_id, **kwargs):  # noqa: E501
        """Get LDAP Credential  # noqa: E501

        ### LDAP login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_ldap(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: CredentialsLDAP
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.user_credentials_ldap_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_credentials_ldap_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def user_credentials_ldap_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get LDAP Credential  # noqa: E501

        ### LDAP login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_ldap_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: CredentialsLDAP
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_credentials_ldap" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_credentials_ldap`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_ldap', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialsLDAP',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_credentials_looker_openid(self, user_id, **kwargs):  # noqa: E501
        """Get Looker OpenId Credential  # noqa: E501

        ### Looker Openid login information for the specified user. Used by Looker Analysts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_looker_openid(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: CredentialsLookerOpenid
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.user_credentials_looker_openid_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_credentials_looker_openid_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def user_credentials_looker_openid_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get Looker OpenId Credential  # noqa: E501

        ### Looker Openid login information for the specified user. Used by Looker Analysts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_looker_openid_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: CredentialsLookerOpenid
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_credentials_looker_openid" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_credentials_looker_openid`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_looker_openid', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialsLookerOpenid',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_credentials_oidc(self, user_id, **kwargs):  # noqa: E501
        """Get OIDC Auth Credential  # noqa: E501

        ### OpenID Connect (OIDC) authentication login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_oidc(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: CredentialsOIDC
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.user_credentials_oidc_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_credentials_oidc_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def user_credentials_oidc_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get OIDC Auth Credential  # noqa: E501

        ### OpenID Connect (OIDC) authentication login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_oidc_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: CredentialsOIDC
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_credentials_oidc" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_credentials_oidc`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_oidc', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialsOIDC',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_credentials_saml(self, user_id, **kwargs):  # noqa: E501
        """Get Saml Auth Credential  # noqa: E501

        ### Saml authentication login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_saml(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: CredentialsSaml
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.user_credentials_saml_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_credentials_saml_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def user_credentials_saml_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get Saml Auth Credential  # noqa: E501

        ### Saml authentication login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_saml_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: CredentialsSaml
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_credentials_saml" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_credentials_saml`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_saml', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialsSaml',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_credentials_totp(self, user_id, **kwargs):  # noqa: E501
        """Get Two-Factor Credential  # noqa: E501

        ### Two-factor login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_totp(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: CredentialsTotp
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.user_credentials_totp_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_credentials_totp_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def user_credentials_totp_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get Two-Factor Credential  # noqa: E501

        ### Two-factor login information for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_credentials_totp_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :return: CredentialsTotp
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_credentials_totp" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_credentials_totp`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/credentials_totp', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CredentialsTotp',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_for_credential(self, credential_type, credential_id, **kwargs):  # noqa: E501
        """Get User by Credential Id  # noqa: E501

        ### Get information about the user with a credential of given type with specific id.  This is used to do things like find users by their embed external_user_id. Or, find the user with a given api3 client_id, etc. The 'credential_type' matchs the 'type' name of the various credential types. It must be one of the values listed in the table below. The 'credential_id' is your unique Id for the user and is specific to each type of credential.  An example using the Ruby sdk might look like:  `sdk.user_for_credential('embed', 'customer-4959425')`  This table shows the supported 'Credential Type' strings. The right column is for reference; it shows which field in the given credential type is actually searched when finding a user with the supplied 'credential_id'.  | Credential Types | Id Field Matched | | ---------------- | ---------------- | | email            | email            | | google           | google_user_id   | | saml             | saml_user_id     | | oidc             | oidc_user_id     | | ldap             | ldap_id          | | api              | token            | | api3             | client_id        | | embed            | external_user_id | | looker_openid    | email            |  NOTE: 'api' is the legacy Looker query API. The API you are currently looking at is 'api3'.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_for_credential(credential_type, credential_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str credential_type: Type name of credential (required)
        :param str credential_id: Id of credential (required)
        :param str fields: Requested fields.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.user_for_credential_with_http_info(credential_type, credential_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_for_credential_with_http_info(credential_type, credential_id, **kwargs)  # noqa: E501
            return data

    def user_for_credential_with_http_info(self, credential_type, credential_id, **kwargs):  # noqa: E501
        """Get User by Credential Id  # noqa: E501

        ### Get information about the user with a credential of given type with specific id.  This is used to do things like find users by their embed external_user_id. Or, find the user with a given api3 client_id, etc. The 'credential_type' matchs the 'type' name of the various credential types. It must be one of the values listed in the table below. The 'credential_id' is your unique Id for the user and is specific to each type of credential.  An example using the Ruby sdk might look like:  `sdk.user_for_credential('embed', 'customer-4959425')`  This table shows the supported 'Credential Type' strings. The right column is for reference; it shows which field in the given credential type is actually searched when finding a user with the supplied 'credential_id'.  | Credential Types | Id Field Matched | | ---------------- | ---------------- | | email            | email            | | google           | google_user_id   | | saml             | saml_user_id     | | oidc             | oidc_user_id     | | ldap             | ldap_id          | | api              | token            | | api3             | client_id        | | embed            | external_user_id | | looker_openid    | email            |  NOTE: 'api' is the legacy Looker query API. The API you are currently looking at is 'api3'.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_for_credential_with_http_info(credential_type, credential_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str credential_type: Type name of credential (required)
        :param str credential_id: Id of credential (required)
        :param str fields: Requested fields.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['credential_type', 'credential_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_for_credential" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'credential_type' is set
        if ('credential_type' not in params or
                params['credential_type'] is None):
            raise ValueError("Missing the required parameter `credential_type` when calling `user_for_credential`")  # noqa: E501
        # verify the required parameter 'credential_id' is set
        if ('credential_id' not in params or
                params['credential_id'] is None):
            raise ValueError("Missing the required parameter `credential_id` when calling `user_for_credential`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'credential_type' in params:
            path_params['credential_type'] = params['credential_type']  # noqa: E501
        if 'credential_id' in params:
            path_params['credential_id'] = params['credential_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/credential/{credential_type}/{credential_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_roles(self, user_id, **kwargs):  # noqa: E501
        """Get User Roles  # noqa: E501

        ### Get information about roles of the user with a specific id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_roles(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :param bool direct_association_only: Get only roles associated directly with the user: exclude those only associated through groups.
        :return: list[Role]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.user_roles_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_roles_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def user_roles_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get User Roles  # noqa: E501

        ### Get information about roles of the user with a specific id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_roles_with_http_info(user_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: id of user (required)
        :param str fields: Requested fields.
        :param bool direct_association_only: Get only roles associated directly with the user: exclude those only associated through groups.
        :return: list[Role]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'fields', 'direct_association_only']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_roles" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_roles`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501
        if 'direct_association_only' in params:
            query_params.append(('direct_association_only', params['direct_association_only']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/roles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Role]',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def user_session(self, user_id, session_id, **kwargs):  # noqa: E501
        """Get Web Login Session  # noqa: E501

        ### Web login session for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_session(user_id, session_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param int session_id: Id of Web Login Session (required)
        :param str fields: Requested fields.
        :return: Session
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.user_session_with_http_info(user_id, session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.user_session_with_http_info(user_id, session_id, **kwargs)  # noqa: E501
            return data

    def user_session_with_http_info(self, user_id, session_id, **kwargs):  # noqa: E501
        """Get Web Login Session  # noqa: E501

        ### Web login session for the specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.user_session_with_http_info(user_id, session_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param int user_id: Id of user (required)
        :param int session_id: Id of Web Login Session (required)
        :param str fields: Requested fields.
        :return: Session
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id', 'session_id', 'fields']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method user_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `user_session`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `user_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['user_id'] = params['user_id']  # noqa: E501
        if 'session_id' in params:
            path_params['session_id'] = params['session_id']  # noqa: E501

        query_params = []
        if 'fields' in params:
            query_params.append(('fields', params['fields']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/users/{user_id}/sessions/{session_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Session',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
